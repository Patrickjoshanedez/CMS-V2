# Capstone Management System (CMS) — Project Rules & Instructions

These six rules govern all architectural decisions, implementation patterns, and code contributions for the Capstone Management System with Plagiarism Checker. Every module, feature, and code change must comply with these instructions.

---

## Rule 1: System Architecture and Tech Stack

**Stack:** MERN (MongoDB, Express.js, React, Node.js)

All development must use a unified JavaScript/TypeScript ecosystem built on the MERN stack. This is non-negotiable.

### Mandates

- **Frontend:** React 18+ with Vite as the build tool. All UI is component-based with functional components and hooks only — no class components.
- **UI Component Library:** [shadcn/ui](https://ui.shadcn.com/) is the **standard component library** for this project. All common UI elements (buttons, inputs, dialogs, dropdowns, tables, cards, tabs, toasts, etc.) must use shadcn/ui components — **do not build custom equivalents** when a shadcn/ui component exists.
  - shadcn/ui components are installed individually into the project (they are **not** an npm dependency — they live in the codebase under a `components/ui/` directory).
  - All shadcn/ui components are built on **Radix UI** primitives and styled with **Tailwind CSS**, ensuring accessibility (WAI-ARIA) and composability out of the box.
  - When extending or wrapping a shadcn/ui component, create a new component that composes the original — never modify the generated source files directly, so they remain upgradeable.
  - Use shadcn/ui's built-in theming and CSS variable system as the foundation for all design tokens (colors, radii, spacing). Custom design tokens must be added to the same CSS variable layer — never hardcode hex/rgb values in components.
- **Backend:** Node.js with Express.js for the REST API layer. All routes must follow RESTful conventions (`GET`, `POST`, `PUT`, `PATCH`, `DELETE`).
- **Database:** MongoDB with Mongoose ODM. All data models must be defined as Mongoose schemas with proper validation, indexing, and virtuals where applicable.
- **API Communication:** All client-server communication uses JSON over HTTP. Axios is the standard HTTP client on the frontend.
- **Folder Structure:** The project must maintain a clear separation:
  ```
  /client    → React frontend (Vite)
  /server    → Express backend
  /shared    → Shared types, constants, or utilities
  /reference → Documentation and design assets
  ```
- **Service Layer Architecture:** Do **not** place complex business logic (plagiarism checker algorithms, document locking rules, phase transition logic, approval workflows) inside Express controllers. Controllers must be **thin** — they handle HTTP request/response only and delegate to a dedicated `/services` layer where all core business logic resides. This separation makes logic testable independently of the HTTP layer.
- **Feature-Modular Organization:** As the codebase grows, prefer grouping files **by feature/domain** in addition to the base layer separation. For example:
  ```
  /server
    /modules
      /capstones    → controller, service, model, routes, validation for capstones
      /users        → controller, service, model, routes, validation for users
      /submissions  → controller, service, model, routes, validation for submissions
      /plagiarism   → controller, service, jobs, routes for originality checks
    /middleware     → Shared middleware (auth, RBAC, error handler, file upload)
    /utils          → Shared helpers and utilities
    /config         → Database, storage, and third-party service configs
  ```
  This prevents monolithic folders with dozens of unrelated files and makes ownership clear when multiple developers work in parallel.
- **Centralized Error Handling:** Create a **global error-handling middleware** in Express. All thrown or forwarded errors must flow through this middleware so the frontend always receives a **consistent JSON error format**:
  ```json
  {
    "success": false,
    "error": {
      "code": "DOCUMENT_LOCKED",
      "message": "This chapter is locked. Submit an unlock request to your adviser.",
      "status": 403
    }
  }
  ```
  Whether an upload fails, a database query times out, or a validation rule is violated, the response shape must be identical. The frontend can then rely on a single error-parsing utility.
- **NoSQL Design:** Leverage MongoDB's flexible document model for complex, nested data (user profiles, team associations, multi-phase project submissions). Avoid forcing relational patterns into the document store — use embedding for tightly coupled data and referencing (ObjectId) for loosely coupled entities.
- **Database Indexing:** Add indexes to every frequently queried field. At minimum, index `academicYear`, `keywords`, `title`, and `status` on capstone/archive collections, and compound indexes on fields used together in filters (e.g., `{ academicYear: 1, status: 1 }`). Without proper indexing, archive searches degrade to full-collection scans as data grows.
- **Environment Config:** All environment-specific values (ports, DB URIs, API keys, secrets) must be stored in `.env` files and accessed via `process.env`. Never hardcode secrets or connection strings.

### Why

A cohesive, JavaScript-based ecosystem reduces context-switching, enables code sharing between client and server, and provides the flexibility needed for dynamic interfaces and deeply nested academic project data. Using shadcn/ui ensures consistent, accessible, and themeable components without the overhead of a monolithic UI framework.

---

## Rule 2: Security and Role-Based Access Control (RBAC)

**Principle:** Zero trust by default. Every route, action, and data query must be permission-gated.

### Roles

| Role         | Access Level |
|--------------|-------------|
| **Instructor** (Research Coordinator / Admin) | Full system oversight: manage users, manage the archive, bulk-upload legacy documents, bypass standard workflows, generate reports. |
| **Adviser**    | Review and comment on assigned groups' chapter drafts (highlight & comment tool), approve/reject submissions, receive upload notifications. |
| **Panelist** (Co-Panel) | View drafted topics and chapters, select groups to handle, grade/evaluate defenses. |
| **Student**    | Submit documents, track project progress, manage team membership, view limited archive (journal versions only). |

### Mandates

#### 2A. Identity & Access Management (OWASP #1: Broken Access Control)

- **Authentication:** JWT-based authentication with HTTP-only, secure, and `SameSite=Strict` cookies for token storage. Refresh token rotation must be implemented. **Never** store JWTs in `localStorage` — if an XSS vulnerability exists, attackers can extract tokens via JavaScript. HTTP-only cookies are immune to this attack vector.
- **Session Revocation:** Implement a server-side token blacklist or revocation list. When a user logs out or an account is compromised, their active tokens must be immediately invalidated — not just removed from the client.
- **Authorization Middleware:** Every API endpoint must pass through an `authorize(roles[])` middleware that verifies the user's role against the required permission before executing any controller logic. A token belonging to a Student or Panelist must immediately trigger a `403 Forbidden` if they attempt to hit an Instructor-only endpoint (e.g., accessing the full Academic manuscript or bulk-uploading archives).
- **Data Isolation:**
  - Students searching the archive may **only** view and access the condensed **Journal/Publishable Version** of past research.
  - The full **Academic Version** is restricted to authorized faculty (Instructors, Advisers, Panelists) and may only be opened within the system — never downloaded directly by students.
- **Document Locking:** Approved chapters are **locked by default**. Students must submit an "Unlock Request" to their Adviser before making further edits. The lock status must be enforced server-side, not just in the UI.
- **Title Modification:** Editing an approved project title requires submitting a formal request/approval letter to the Instructor. The title status must reflect "Pending" until the Instructor marks it "Approved."

#### 2B. Document Upload & File Handling Security

- **MIME-Type & Size Validation:** When teams upload Chapter 1–3 drafts, final certificates, or prototype media, **never trust the file extension** provided by the client. Use `multer` combined with a library like `file-type` on the Node.js server to inspect the **actual binary signature** (magic bytes) of each file. Enforce strict file-size limits to prevent Denial of Service (DoS) attacks via massive payloads.
- **Secure Cloud Storage:** Do not store uploaded capstone documents on the Node.js file system. Upload them to a **private** cloud bucket (e.g., AWS S3 or Google Cloud Storage). When an authorized user needs to view a document (e.g., in the split-screen UI or adviser review tool), the server must generate a **temporary, expiring Pre-signed URL** — never expose permanent public links to academic manuscripts.
- **File Type Allowlist:** Maintain an explicit allowlist of accepted MIME types (e.g., `application/pdf`, `image/png`, `image/jpeg`, `video/mp4`). Reject everything else at the middleware layer before it reaches any controller.

#### 2C. Database & Input Security (OWASP: Injection Prevention)

- **NoSQL Injection Prevention:** MongoDB is vulnerable to operator injection. **Never** pass raw `req.body` or `req.query` directly into Mongoose queries. Attackers can inject operators like `{ "$ne": null }` to bypass authentication or extract unauthorized data. Use strict schema-based validation to coerce all inputs to expected types before querying.
- **Input Validation & Sanitization:** Use `express-validator`, `joi`, or `zod` to define strict schemas for every incoming request. For example, when searching the archive for research gaps, strip all special characters and validate that the `year` filter is a 4-digit number. Never trust client-side validation alone.
- **Password Security:** Passwords must be hashed with **bcrypt** (minimum 12 salt rounds) or **Argon2** with a unique salt. Plaintext passwords must never be stored, logged, or included in API responses.

#### 2D. Securing the API & Plagiarism Workflows

- **Rate Limiting:** Apply `express-rate-limit` globally, with **aggressive limits** on authentication routes (`/login`, `/register`, `/forgot-password`) and resource-heavy endpoints (plagiarism submission, bulk upload). If the originality checker runs as a background job, rate limiting prevents malicious users from spam-queuing jobs and exhausting server CPU or external API quotas.
- **CORS Configuration:** Explicitly configure allowed origins in Express. **Never** use wildcard `*` in production. Only the specific React frontend URL should be permitted.
- **HTTP Security Headers:** Use the `helmet` package in Express. It automatically configures secure HTTP headers to protect against clickjacking (`X-Frame-Options`), cross-site scripting (`X-XSS-Protection`), MIME-sniffing (`X-Content-Type-Options`), and other common attack vectors.

#### 2E. Security Testing & Dependency Management

- **Automated Security Test Cases:** The test suite must include **explicit security tests** that intentionally attempt to bypass workflows — for example:
  - A Student attempting to send an "Unlock Request" approval to themselves.
  - A Student attempting to modify an approved title without Instructor oversight.
  - A Panelist attempting to access full Academic manuscripts via direct API calls.
  - Injection payloads in search fields and form inputs.
  - The tests must **assert** that the system successfully blocks these actions with correct HTTP status codes.
- **Dependency Vulnerability Auditing (OWASP A06: Vulnerable & Outdated Components):** Node.js ecosystems rely heavily on third-party packages. Run `npm audit` regularly and integrate a tool like **Snyk** or **Dependabot** to automatically monitor and patch vulnerable dependencies. Never use unmaintained libraries for critical features like cryptography or authentication.

### Why

Protecting data integrity and intellectual property is paramount. A hierarchical RBAC model ensures users only interact with information they are authorized to access, preventing unauthorized viewing of full academic manuscripts and maintaining the integrity of approved documents.

---

## Rule 3: Data Management and File Storage

**Principle:** Separate metadata from binary files. Keep the database lean; offload heavy assets to cloud storage.

### Mandates

- **File Storage:** All uploaded files (PDFs, images, videos, prototype media) must be stored in a cloud storage solution (e.g., AWS S3, Cloudinary, or equivalent). The MongoDB database stores only the file's metadata:
  - `fileName`, `fileType`, `fileSize`
  - `storageUrl` (the cloud URL or key)
  - `version` (integer, auto-incremented on re-upload)
  - `status` (e.g., `pending`, `under_review`, `approved`, `locked`)
  - `uploadedBy`, `uploadedAt`
  - `academicYear`, `capstonePhase`
- **Versioning:** Every document re-upload creates a new version record. Previous versions must be retained and accessible to Advisers and Instructors for audit purposes.
- **Dual Version Upload (Capstone 4):** The final submission must include exactly two files:
  1. **Full Academic Version** — restricted access (faculty only, viewable within the system).
  2. **Journal/Publishable Version** — public-facing for archive searches.
- **Originality Check Integration:** Uploaded papers must pass through an automated originality/plagiarism checker. The system must store and display the **percentage of original content** for each submission. This process should run as an asynchronous background job (see Rule 5) to avoid blocking the UI.
- **Split-Screen Support:** The document viewing module must support opening and comparing two files side-by-side. This requires efficient file retrieval — use signed URLs with expiration for secure, performant access to cloud-stored files.
- **Late Submission Handling:** If a submission exceeds its deadline, the system must prompt the team to add a mandatory "remarks" section explaining the delay **before** accepting the file upload. The backend must enforce this — not just the frontend.
- **Archive Search:** The archive must support advanced search with filters for **year**, **topic**, and **keyword**. MongoDB text indexes or a dedicated search layer (e.g., Atlas Search) should be used for performant full-text searching.
- **Bulk Upload (Instructor Only):** Instructors must have the ability to bulk-upload and archive previous years' physical documents, bypassing the standard submission workflow.

### Why

Managing large binary files directly in MongoDB degrades performance. Offloading to cloud storage while maintaining precise metadata in the database ensures the system remains fast, searchable, and scalable — even as the archive grows over multiple academic years.

---

## Rule 4: User Experience (UX) and State Management

**Principle:** Guide users through complexity. Make every status, action, and error explicit and intuitive.

### Mandates

- **State Management:** Use Zustand for client-side global state and React Query (TanStack Query) for all server-state (data fetching, caching, mutations). Do not use Redux unless explicitly justified.
- **Phased Workflow UI:** The capstone process must be broken into distinct, trackable phases in the UI:
  1. **Team Formation** → 2. **Topic Submission & Approval** → 3. **Chapter 1–3 Individual Uploads** → 4. **Full Proposal Compilation** → 5. **Development (Capstone 2 & 3)** → 6. **Final Defense & Archiving (Capstone 4)**
  - Each phase must show clear **status indicators**: `Not Started`, `In Progress`, `Submitted`, `Under Review`, `Approved`, `Locked`, `Rejected`.
- **Individual to Team Flow:** Students register individual accounts first, then create or join a project team. The UI must clearly guide this two-step process.
- **Orphaned Student Adoption:** The system must allow existing teams to send invites to students who have separated from their original groups. The UI must provide a clear, discoverable pathway for this.
- **Topic Duplicate Detection:** When a team submits a proposal, the system must **immediately** cross-reference the database and alert the team if the proposed topic already exists or is highly similar.
- **Adviser Review Tools:** The document review interface must include a **highlight and comment tool** so Advisers can annotate documents directly within the system. Advisers must receive notifications upon new uploads.
- **Error & Exception Handling:**
  - Late submissions → Mandatory remarks prompt (enforced, not skippable).
  - Project rejection → A clear "Create Another Project" action that resets the workflow from the beginning.
  - Deadline approaches → Visual warnings (e.g., color changes, countdown indicators).
- **Loading & Empty States:** Every data-dependent view must handle three states: **loading** (spinner/skeleton), **empty** (helpful message + call to action), and **error** (retry option + clear error message).
- **Responsive Design:** The UI must be fully responsive across desktop and tablet viewports. Mobile support is secondary but the layout must not break.
- **Dark / Light Mode (Mandatory):**
  - The system must support **both dark and light themes** with a user-toggleable switch (persisted in `localStorage` or user profile).

  ##### 4A. Technical Implementation Strategy
  - Theme implementation must use the **CSS variable strategy** provided by shadcn/ui (`class` strategy on `<html>` — toggling a `.dark` class). Do **not** implement a parallel theming system.
  - **Semantic CSS Variables:** Define all color tokens as global CSS variables in `globals.css` (e.g., `--background`, `--foreground`, `--muted`, `--border`, `--primary`, `--destructive`). Tailwind maps these variables to utility classes. Write `bg-background text-foreground` **once** — the browser handles the color swap automatically when the `.dark` class is applied/removed from `<html>`.
  - **Theme State Management:** Use a dedicated theme context (e.g., a custom React Context + `useTheme` hook, or `next-themes` if migrating to Next.js) to manage the current mode. The context must expose: `theme` (current value), `setTheme` (manual toggle), and `systemTheme` (OS preference).
  - **Default Theme:** The system must default to the user's **OS/browser preference** (`prefers-color-scheme`) on first visit. Any explicit user toggle thereafter takes precedence and is persisted to `localStorage`. On subsequent visits, the stored preference is applied before the first paint to prevent a flash of the wrong theme.
  - **All components, pages, and custom styles** must be dark-mode compatible. Every color, background, border, shadow, and text value must reference Tailwind's CSS variables rather than static colors.

  ##### 4B. Color Palette & Contrast Rules
  Dark mode is **not** simply "inverted light mode." Specific shade and saturation choices are required:
  - **Avoid Pure Black and Pure White:** Pure black (`#000000`) causes eye strain — high-contrast white text "smears" on OLED/LCD screens. Use dark slate or charcoal (e.g., Tailwind's `slate-950` or `zinc-900`) for dark-mode backgrounds. Similarly, use a soft off-white (e.g., `#f8fafc` / `slate-50`) for light-mode backgrounds instead of pure `#ffffff`.
  - **Desaturated Accents in Dark Mode:** Bright primary colors that look great in light mode can "vibrate" against dark backgrounds. Desaturate primary buttons and links slightly in dark mode. For example, a saturated blue button in light mode should become a softer, pastel blue in dark mode to maintain readability. Define separate `--primary` values in the `:root` and `.dark` sections of `globals.css`.
  - **Status Color Adjustments:** Workflow status badges must remain **visually distinct** in both modes. Recommended pairings:
    | Status | Light Mode | Dark Mode |
    |--------|-----------|-----------|
    | `Approved` | Dark green | Bright pastel mint |
    | `Revisions Required` | Burnt orange | Soft amber |
    | `Locked` | Dark gray | Light slate |
    | `Rejected` | Deep red | Soft coral / rose |
    | `Submitted` / `Under Review` | Indigo / blue | Pastel sky blue |
  - **Contrast & Accessibility:** Both themes must meet **WCAG 2.1 AA** contrast ratios (minimum 4.5:1 for normal text, 3:1 for large text and UI components). Test every screen in both modes before merging. Use browser DevTools or a tool like "axe" to audit.

  ##### 4C. Document Viewer & Split-Screen Handling
  The most challenging dark-mode case in a document-heavy application is the PDF viewer and the split-screen comparison UI:
  - **The "Canvas" Rule:** The interface **around** the document (sidebars, navbars, comment panes, toolbars) must strictly obey the dark/light toggle. However, the **actual rendered PDF or academic manuscript** must remain on a **white (or very soft cream) "paper" background** even in dark mode. This preserves standard formatting, chart legibility, image colors, and highlighting accuracy.
  - **Dimming the Canvas:** To prevent the bright white document from blinding users in dark mode, apply a subtle reduction — e.g., an off-white background (`#f3f4f6`) or a slight `brightness(0.95)` CSS filter — to the document container. Do **not** invert the document colors.
  - **Comment Highlights:** When advisers use the highlight and comment tool, ensure highlight colors (typically translucent yellow or green overlays) remain visible and legible regardless of the surrounding theme. Test highlighting on documents in both dark and light modes.

  ##### 4D. Elevation and Depth (Shadows vs. Borders)
  Communicating UI hierarchy (modals for "Title Modification Request," dropdowns for panelist topic selection, floating action menus) requires **different techniques per theme**:
  - **Light Mode Depth:** Use drop shadows (`shadow-sm`, `shadow-md`, `shadow-lg`) to lift cards, modals, and dropdowns visually off the background.
  - **Dark Mode Depth:** Shadows are nearly invisible on dark backgrounds. Instead of relying on shadows, use **surface lightness and borders**:
    - A modal in dark mode should have a slightly lighter background (e.g., `bg-slate-800` sitting on `bg-slate-950`).
    - Add a subtle, semi-transparent border (`border-white/10`) to separate it from content beneath.
    - Cards and panels should use incremental surface-level backgrounds (each level 1–2 shades lighter than its parent) rather than shadows.
  - Define CSS variables for surface levels (e.g., `--card`, `--popover`) that automatically swap between shadow-appropriate and border-appropriate values per theme.

  ##### 4E. Typography and Weight Adjustments
  Light text on a dark background inherently **appears thicker** than dark text on a light background due to how screens emit light (subpixel rendering behavior):
  - **Font Smoothing:** Apply `antialiased` (Tailwind's `antialiased` class) globally on the `<body>` element in both modes to normalize text rendering.
  - **Weight Adjustments:** If you use `font-semibold` (600) for headers in light mode, consider dropping to `font-medium` (500) in dark mode to prevent text from appearing overly heavy or blurry. Define a utility or CSS variable for heading weights per theme if needed.
  - **Muted Text:** For secondary information (timestamps, late submission remarks, minor UI labels), rely heavily on the `--muted-foreground` CSS variable. In dark mode, this should be a soft gray that recedes visually but still **passes WCAG AA** contrast against the dark background.

  ##### 4F. Prohibited Patterns (Enforced in Code Review)
  - Hardcoded color values (`#ffffff`, `rgb(0,0,0)`, `bg-white`, `text-black`, `text-gray-900`) in **any** component, utility class, or Tailwind config extension.
  - Inline `style` attributes that set colors directly (e.g., `style={{ color: 'red' }}`).
  - Conditional class logic that only handles one mode (e.g., applying dark styles but forgetting light defaults, or vice-versa).
  - Using `dark:` variant classes when the same result can be achieved via CSS variables (prefer the variable approach for maintainability).

  ##### 4G. Asset & Embed Compatibility
  - **Image & media compatibility:** Logos, icons, and illustrations must remain legible in both modes. Use SVGs with `currentColor` where possible, or provide light/dark asset variants and swap them based on the active theme.
  - **Third-party embeds:** Any embedded viewer (PDF viewer, video player, code editor) must be themed or wrapped in a container that prevents jarring contrast mismatches against the active mode.
- **Prototype Showcasing (Capstone 2 & 3):** Students must be able to present system prototypes by uploading images, videos, or providing external web links directly within their project workspace.

### Why

Complex, multi-step academic workflows overwhelm users when presented as monolithic forms. Breaking them into guided phases with clear status tracking, intuitive error handling, and frictionless exception pathways reduces cognitive load and prevents user errors.

---

## Rule 5: Scalability and External Integrations

**Principle:** Build modular. Offload heavy work. Design for growth.

### Mandates

- **Modular Backend Services:** The Express backend must be organized into modular service layers:
  ```
  /server
    /controllers   → Route handlers (thin — delegate to services)
    /services      → Business logic (thick — all core logic lives here)
    /models        → Mongoose schemas and models
    /middleware     → Auth, RBAC, error handling, file upload
    /routes        → Route definitions (grouped by resource)
    /jobs          → Background job definitions
    /utils         → Shared helpers and utilities
    /config        → Database, storage, and third-party service configs
  ```
- **Background Job Processing:** Resource-heavy operations must **never** run synchronously in the request-response cycle. Use a job queue system (e.g., BullMQ with Redis) for:
  - **Plagiarism/Originality Checks** — Text comparison is CPU-intensive; queue it and notify the user upon completion.
  - **PDF Generation** (e.g., certificates, reports).
  - **Bulk File Processing** (Instructor bulk uploads).
  - **Email/Notification Dispatch.**
- **Plagiarism Checker Architecture:** The originality checker must be designed as an independent, asynchronous service:
  1. Student uploads document → API saves file and enqueues a plagiarism job.
  2. Background worker processes the job (text extraction → comparison against archive → similarity scoring).
  3. Upon completion, the result (originality percentage) is stored in the database and the student is notified.
  4. The UI polls or uses WebSockets to display the result without requiring a page refresh.
- **Notification System:** Implement a centralized notification service that supports:
  - **In-app notifications** (real-time via WebSockets or SSE).
  - **Email notifications** (queued as background jobs).
  - Triggered by events: uploads, approvals, rejections, deadline warnings, invite requests, unlock requests.
- **API Rate Limiting:** Apply rate limiting middleware to all public-facing and authentication endpoints to prevent abuse.
- **CORS Configuration:** Explicitly configure allowed origins. Never use `*` in production.
- **Instructor Reporting:** The system must support generating reports filtered by **author**, **title**, and **year**, showing the total number of capstones uploaded per academic year. Reports should be generated as background jobs if data volume is large.
- **Future-Proofing:** All external integrations (storage, plagiarism API, email service) must be abstracted behind service interfaces. Swapping out a provider (e.g., switching from S3 to Google Cloud Storage) should require changes in only one file — the service adapter — not across the entire codebase.
- **Pagination & Lazy Loading:** Never send thousands of database records to the frontend at once. Implement **cursor-based or offset pagination** for all list endpoints (archive search, submission history, user lists). On the frontend, lazy-load heavy React components (PDF viewer, split-screen module, rich-text editor) using `React.lazy()` and `Suspense` so they only load when the user navigates to them.
- **Caching Strategy:** If data rarely changes — such as the list of available instructors, dashboard statistics for a completed academic year, or published archive metadata — cache it using **Redis** or HTTP cache headers (`Cache-Control`, `ETag`). Use React Query's `staleTime` and `cacheTime` on the frontend to prevent redundant refetches of stable data.
- **Asynchronous Background Processing:** Heavy tasks must **never** block the main Express thread. When a student uploads a full capstone paper, the originality check must be offloaded to a background queue (BullMQ + Redis). The API should return a `202 Accepted` with a "Processing" status immediately. The UI either polls a status endpoint or listens via WebSocket for the result.

### Why

A web system that processes plagiarism checks synchronously, sends emails inline, or tightly couples to a single storage provider will buckle under real-world usage. Modular services, asynchronous job queues, provider-agnostic abstractions, intelligent caching, and paginated data delivery ensure the system remains responsive, maintainable, and ready for growth.

---

## Rule 6: Team Coding Standards, Version Control & Refactoring

**Principle:** Consistency across contributors. Clean code is a team discipline, not an individual preference.

### 6A. Version Control & Git Workflow

- **Strict Git Branching:** Never push directly to the `main` branch. Use a **feature-branch workflow**:
  - `main` — production-ready, protected.
  - `develop` — integration branch for testing.
  - `feature/<name>` — individual feature work (e.g., `feature/split-screen-ui`, `feature/plagiarism-checker`).
  - `fix/<name>` — bug fixes.
- **Pull Requests (PRs):** Every merge into `develop` or `main` requires a PR reviewed by **at least one other team member**. PRs must include a description of what changed and why.
- **Commit Messages:** Follow conventional commit format:
  ```
  feat: add adviser highlight-and-comment tool
  fix: resolve document locking bypass on direct API call
  refactor: extract plagiarism scoring into dedicated service
  docs: update API endpoint documentation
  style: fix dark-mode contrast on status badges
  test: add security tests for RBAC middleware
  chore: update dependencies, run npm audit
  ```

### 6B. Linting, Formatting & Code Quality

- **Enforced Code Style:** Use **ESLint** and **Prettier** with a shared configuration committed to the repository (`.eslintrc.js`, `.prettierrc`). All team members must use the same rules.
- **Git Hooks:** Install **Husky** to run `lint-staged` on every commit. This automatically formats staged files before they are committed, eliminating style debates and ensuring the codebase reads as if written by a single person.
- **No `console.log` in Production Code:** Use a structured logger (e.g., `winston` or `pino`) on the backend. On the frontend, strip `console.log` statements before merging — wrap development-only logging behind an environment check or remove it entirely.

### 6C. Refactoring Best Practices

Refactoring is restructuring existing code to make it cleaner and more efficient **without changing its external behavior**.

- **Refactor Incrementally:** Do not attempt to rewrite the entire system at once. Refactor small, manageable chunks — a single messy React component, one slow MongoDB query, or one bloated controller at a time.
- **Write Tests First (Red-Green-Refactor):** Before refactoring complex logic (e.g., the approval workflow from Capstone 1 to Capstone 2, or the plagiarism queue), write test cases that assert the current correct behavior. Having tests guarantees that the refactoring does not break existing features.
- **Single Responsibility Principle:** A function should do **one thing**. If an Express controller is validating input, querying the database, sending an email, and formatting a date, it is doing too much. Break it into smaller, reusable helper functions and delegate to the service layer.
- **Eliminate Prop Drilling:** If you find yourself passing state through five or more levels of React components, refactor to use Zustand (global state), React Context (scoped state), or React Query (server state). Deep prop drilling is a code smell.
- **Remove Dead Code:** Unused imports, commented-out blocks, and unreachable branches must be deleted, not left "just in case." Version control preserves history — dead code in the working tree only creates confusion.

### Why

A team that shares coding standards, enforces automated formatting, and refactors incrementally with test coverage produces code that any member can read, debug, and extend — even months after the original author has moved on.

---

## Rule 7: Living Documentation

**Principle:** Documentation is a first-class deliverable — not an afterthought. It must be accurate, current, and updated on every iteration.

### Mandates

#### 7A. Documentation-as-Code

- **Co-located Documentation:** All project documentation lives inside the repository under `/docs`. It is version-controlled alongside the code it describes. Documentation changes must be part of the **same PR** as the code changes they relate to — never a separate "docs catch-up" PR weeks later.
- **Required Documentation Artifacts:** The project must maintain the following living documents at all times:
  ```
  /docs
    README.md                → Project overview, setup instructions, quick-start guide
    ARCHITECTURE.md           → High-level system architecture, tech stack, data flow diagrams
    API.md                    → All REST API endpoints (method, path, request/response schemas, auth requirements)
    DATABASE.md               → MongoDB collections, schemas, indexes, relationships
    DEPLOYMENT.md             → Environment setup, deployment steps, environment variables
    CHANGELOG.md              → Version history following Keep a Changelog format (https://keepachangelog.com)
    CONTRIBUTING.md           → Branch strategy, PR process, commit conventions, code review checklist
    /guides
      STUDENT_GUIDE.md        → End-user guide for the Student role
      ADVISER_GUIDE.md        → End-user guide for the Adviser role
      PANELIST_GUIDE.md       → End-user guide for the Panelist role
      INSTRUCTOR_GUIDE.md     → End-user guide for the Instructor/Admin role
  ```
- **Root README.md:** Must always reflect the current state of the project: what it does, how to install and run it locally, which environment variables are required, and links to all other documentation files. A new contributor should be able to clone the repo and have the system running locally by following the README alone.

#### 7B. Iteration-Driven Updates

- **Every Sprint / Iteration Must Update Docs:** At the end of each development iteration (feature, sprint, or milestone), the following documentation must be reviewed and updated:
  1. `CHANGELOG.md` — What was added, changed, deprecated, removed, fixed, or patched.
  2. `API.md` — Any new or modified endpoints.
  3. `DATABASE.md` — Any schema changes, new collections, or index additions.
  4. `ARCHITECTURE.md` — Any new services, integrations, or architectural shifts.
  5. Role-specific guides — If a workflow changed for any user role.
- **PR Documentation Checklist:** Every Pull Request template must include a mandatory checklist item:
  ```
  - [ ] Documentation updated (README, API, DATABASE, CHANGELOG, guides) if applicable
  ```
  PRs that introduce new features, modify APIs, or change workflows **must not be merged** without corresponding documentation updates. Reviewers must verify this.
- **No Stale Docs:** If a feature is removed or an API endpoint is deprecated, the documentation must reflect this immediately — not "eventually." Stale documentation is worse than no documentation because it actively misleads.

#### 7C. Documentation Standards & Formatting

- **Markdown Only:** All documentation files use GitHub-Flavored Markdown (GFM). No Word docs, no Google Docs links, no PDFs for living documentation.
- **Consistent Structure:** Every documentation file must include:
  - A title (`# Title`)
  - A "Last Updated" date at the top (e.g., `> Last updated: 2026-02-28`)
  - A table of contents for files longer than 3 sections
  - Clear section headings (`##`, `###`)
- **API Documentation Format:** Each endpoint in `API.md` must document:
  ```
  ### POST /api/submissions/:projectId/chapters
  
  **Description:** Upload a chapter draft for a capstone project.
  **Auth:** Bearer token (JWT). Roles: `student`
  **Rate Limit:** 10 requests/minute
  
  **Request Body:**
  | Field       | Type   | Required | Description                    |
  |-------------|--------|----------|--------------------------------|
  | chapterId   | string | yes      | Chapter number (1-5)           |
  | file        | binary | yes      | PDF/DOCX/TXT, max 25MB        |
  | remarks     | string | conditional | Required if past deadline    |
  
  **Response (201):**
  { "success": true, "data": { "submissionId": "...", "status": "pending" } }
  
  **Error (409):**
  { "success": false, "error": { "code": "CONCURRENT_SUBMISSION", "message": "...", "status": 409 } }
  ```
- **Database Documentation Format:** Each collection in `DATABASE.md` must document:
  - Collection name
  - Schema fields with types, constraints, and descriptions
  - Indexes (single, compound, text)
  - Relationships (references to other collections)
  - Example document
- **Changelog Format:** Follow [Keep a Changelog](https://keepachangelog.com) strictly:
  ```
  ## [0.3.0] - 2026-02-28
  ### Added
  - Plagiarism checker integration with Copyleaks API
  - Background job queue for async similarity processing
  ### Changed
  - Submission endpoint now returns 202 Accepted for plagiarism jobs
  ### Fixed
  - Document locking bypass on direct API call
  ```

#### 7D. Inline Code Documentation

- **JSDoc for All Public Functions:** Every exported function, service method, and API controller must include a JSDoc comment describing its purpose, parameters, return value, and thrown errors:
  ```javascript
  /**
   * Enqueue a plagiarism check job for the given submission.
   * @param {string} submissionId - The MongoDB ObjectId of the submission.
   * @param {string} filePath - Cloud storage path to the uploaded document.
   * @returns {Promise<string>} The BullMQ job ID for tracking.
   * @throws {AppError} If the submission does not exist or is already being processed.
   */
  async function enqueuePlagiarismCheck(submissionId, filePath) { ... }
  ```
- **Mongoose Schema Comments:** Every Mongoose model must include a file-level comment describing the collection's purpose and a brief field-level comment for non-obvious fields:
  ```javascript
  /**
   * Submission model — tracks individual chapter uploads per capstone project.
   * Each re-upload increments the version; previous versions are retained.
   */
  const submissionSchema = new Schema({
    projectId: { type: Schema.Types.ObjectId, ref: 'Project', required: true },
    chapter: { type: Number, min: 1, max: 5, required: true },
    version: { type: Number, default: 1 }, // Auto-incremented on re-upload
    status: { type: String, enum: ['pending', 'under_review', 'approved', 'locked', 'rejected'] },
    originalityScore: { type: Number, default: null }, // Populated async by plagiarism job
  });
  ```
- **No Redundant Comments:** Comments must explain **why**, not **what**. Do not write `// increment counter` above `counter++`. Do write `// Retry up to 3 times because Copyleaks occasionally returns 503 under heavy load`.

#### 7E. Automated Documentation Validation

- **Linting for Docs:** Use a Markdown linter (e.g., `markdownlint`) in the CI pipeline to enforce consistent formatting across all `.md` files.
- **Link Checking:** Use a link checker in CI to verify that no internal documentation links are broken after refactoring or renaming.
- **API Schema Sync (Optional):** If time permits, generate API documentation from route definitions using tools like `swagger-jsdoc` or `tsoa` to ensure the API docs never drift from the actual implementation.

### Why

In an academic capstone project with multiple contributors working across semesters, undocumented code becomes unreadable within weeks. Living documentation — updated on every iteration and enforced through PR checklists — ensures that advisers, panelists, and future maintainers can understand, evaluate, and extend the system without reverse-engineering it from source code. Documentation is not extra work; it is the work.

---

## Summary

| Rule | Core Directive |
|------|---------------|
| **1. Architecture** | MERN stack, shadcn/ui component library, service layer architecture, feature-modular folders, centralized error handling, DB indexing, environment-based config. |
| **2. Security & RBAC** | JWT in HTTP-only cookies, OWASP-aligned RBAC middleware, session revocation, MIME-type file validation, NoSQL injection prevention, `helmet` headers, security test cases, dependency auditing. |
| **3. Data & Files** | Cloud storage for binaries, metadata in MongoDB, versioning, dual-version finals, async plagiarism checks, signed URLs. |
| **4. UX & State** | Phased workflows, clear status indicators, guided error handling, Zustand + React Query, comprehensive dark/light mode (CSS variables, color palette rules, document canvas rule, elevation strategy, typography adjustments). |
| **5. Scalability** | Modular services, background job queues, abstracted integrations, real-time notifications, pagination, caching, lazy loading. |
| **6. Team Standards** | Feature-branch Git workflow, PR reviews, ESLint + Prettier + Husky, conventional commits, incremental refactoring with tests, single responsibility principle. |
| **7. Living Documentation** | Co-located Markdown docs, iteration-driven updates, PR documentation checklist, CHANGELOG + API + DATABASE + ARCHITECTURE docs, JSDoc for public functions, Mongoose schema comments, automated Markdown linting. |

**Every pull request, code review, and architectural decision must reference and comply with these seven rules.**
